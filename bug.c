/* This file was auto generated by Nelua. */
/* Compile command: gcc -o "nelua_cache\bug" "nelua_cache\bug.c" -Wall -fwrapv -g -lraylib -lm */
/* Compile hash: DcWXDq4xK6gJzQjTNxEpdMb52Xx */

/* ------------------------------ DECLARATIONS ------------------------------ */
#ifdef __GNUC__
#pragma GCC diagnostic error   "-Wimplicit-function-declaration"
#pragma GCC diagnostic error   "-Wimplicit-int"
#pragma GCC diagnostic ignored "-Wincompatible-pointer-types"
#pragma GCC diagnostic ignored "-Wmissing-braces"
#pragma GCC diagnostic ignored "-Wmissing-field-initializers"
#pragma GCC diagnostic ignored "-Wattributes"
#pragma GCC diagnostic ignored "-Wunused-parameter"
#if defined(__clang__)
#pragma GCC diagnostic ignored "-Wunused"
#else
#pragma GCC diagnostic ignored "-Wunused-variable"
#pragma GCC diagnostic ignored "-Wunused-function"
#pragma GCC diagnostic ignored "-Wunused-but-set-variable"
#pragma GCC diagnostic ignored "-Wunused-label"
#pragma GCC diagnostic ignored "-Wdiscarded-qualifiers"
#endif
#pragma GCC diagnostic ignored "-Wtype-limits"
#endif
#if __STDC_VERSION__ >= 201112L
#define nelua_static_assert _Static_assert
#else
#define nelua_static_assert(x, y)
#endif
nelua_static_assert(sizeof(void*) == 8, "Nelua and C disagree on architecture size");
#include <stddef.h>
#include <stdint.h>
#include <stdbool.h>
#include <string.h>
#include <stdlib.h>
#include <stdio.h>
#define nelua_noreturn __attribute__((noreturn))
typedef struct nlstringview nlstringview;
typedef uint8_t* nluint8_arr0_ptr;
struct nlstringview {
  nluint8_arr0_ptr data;
  uintptr_t size;
};
nelua_static_assert(sizeof(nlstringview) == 16, "Nelua and C disagree on type size");
static nelua_noreturn void nelua_panic_stringview(nlstringview s);
#ifdef __GNUC__
#define nelua_likely(x) __builtin_expect(x, 1)
#define nelua_unlikely(x) __builtin_expect(x, 0)
#else
#define nelua_likely(x) (x)
#define nelua_unlikely(x) (x)
#endif
static void nelua_assert_stringview(bool cond, nlstringview s);
static char __strlit1[29] = "memory.copy: invalid pointer";
static inline void nelua_memory_copy(void* dest, void* src, uintptr_t size);
static char __strlit2[29] = "memory.move: invalid pointer";
static inline void nelua_memory_move(void* dest, void* src, uintptr_t size);
static char __strlit3[28] = "memory.set: invalid pointer";
static inline void nelua_memory_set(void* dest, uint8_t x, uintptr_t size);
static char __strlit4[29] = "memory.zero: invalid pointer";
static inline void nelua_memory_zero(void* dest, uintptr_t size);
static inline int32_t nelua_memory_compare(void* a, void* b, uintptr_t size);
static char __strlit5[31] = "memory.equals: invalid pointer";
static inline bool nelua_memory_equals(void* a, void* b, uintptr_t size);
static char __strlit6[29] = "memory.scan: invalid pointer";
static inline void* nelua_memory_scan(void* p, uint8_t x, uintptr_t size);
static char __strlit7[29] = "memory.find: invalid pointer";
typedef uint8_t* nluint8_ptr;
static nelua_noreturn void nelua_panic_cstring(char* s);
static nluint8_ptr nelua_assert_deref_nluint8_ptr(nluint8_ptr p);
static void* nelua_memory_find(void* haystack, uintptr_t haystacksize, void* needle, uintptr_t needlesize);
typedef struct nelua_GCItem nelua_GCItem;
typedef nelua_GCItem* nelua_GCItem_ptr;
typedef void (*nelua_FinalizerCallback)(void*);
struct nelua_GCItem {
  void* ptr;
  uintptr_t flags;
  uintptr_t size;
  uintptr_t hash;
  nelua_FinalizerCallback finalizer;
};
nelua_static_assert(sizeof(nelua_GCItem) == 40, "Nelua and C disagree on type size");
typedef struct nelua_span_GCItem nelua_span_GCItem;
typedef nelua_span_GCItem* nelua_span_GCItem_ptr;
typedef nelua_GCItem* nelua_GCItem_arr0_ptr;
struct nelua_span_GCItem {
  nelua_GCItem_arr0_ptr data;
  uintptr_t size;
};
nelua_static_assert(sizeof(nelua_span_GCItem) == 16, "Nelua and C disagree on type size");
static inline nelua_GCItem_ptr nelua_span_GCItem___atindex(nelua_span_GCItem_ptr self, uintptr_t i);
static inline intptr_t nelua_span_GCItem___len(nelua_span_GCItem_ptr self);
typedef int64_t* nlint64_ptr;
typedef struct bug_span_int64 bug_span_int64;
typedef bug_span_int64* bug_span_int64_ptr;
typedef int64_t* nlint64_arr0_ptr;
struct bug_span_int64 {
  nlint64_arr0_ptr data;
  uintptr_t size;
};
nelua_static_assert(sizeof(bug_span_int64) == 16, "Nelua and C disagree on type size");
static char __strlit8[35] = "span.__atindex: index out of range";
static inline nlint64_ptr bug_span_int64___atindex(bug_span_int64_ptr self, uintptr_t i);
static inline intptr_t bug_span_int64___len(bug_span_int64_ptr self);
typedef Color* Color_ptr;
typedef struct bug_span_Color bug_span_Color;
typedef bug_span_Color* bug_span_Color_ptr;
typedef Color* Color_arr0_ptr;
struct bug_span_Color {
  Color_arr0_ptr data;
  uintptr_t size;
};
nelua_static_assert(sizeof(bug_span_Color) == 16, "Nelua and C disagree on type size");
static inline Color_ptr bug_span_Color___atindex(bug_span_Color_ptr self, uintptr_t i);
static inline intptr_t bug_span_Color___len(bug_span_Color_ptr self);
static inline int64_t nelua_memory_moveval__1(nlint64_ptr a);
static inline Color nelua_memory_moveval__2(Color_ptr a);
typedef struct {uint8_t data[8];} nluint8_arr8;
nelua_static_assert(sizeof(nluint8_arr8) == 8, "Nelua and C disagree on type size");
static inline void nelua_memory_swapval__1(nlint64_ptr a, nlint64_ptr b);
typedef struct {uint8_t data[4];} nluint8_arr4;
nelua_static_assert(sizeof(nluint8_arr4) == 4, "Nelua and C disagree on type size");
static inline void nelua_memory_swapval__2(Color_ptr a, Color_ptr b);
typedef struct nelua_GeneralAllocator nelua_GeneralAllocator;
typedef nelua_GeneralAllocator* nelua_GeneralAllocator_ptr;
struct nelua_GeneralAllocator {
};
nelua_static_assert(sizeof(nelua_GeneralAllocator) == 0, "Nelua and C disagree on type size");
static inline void* nelua_GeneralAllocator_alloc(nelua_GeneralAllocator_ptr self, uintptr_t size);
static inline void* nelua_GeneralAllocator_alloc0(nelua_GeneralAllocator_ptr self, uintptr_t size);
static inline void* nelua_GeneralAllocator_realloc(nelua_GeneralAllocator_ptr self, void* p, uintptr_t newsize, uintptr_t oldsize);
static inline void nelua_GeneralAllocator_dealloc(nelua_GeneralAllocator_ptr self, void* p);
static void* nelua_GeneralAllocator_realloc0(nelua_GeneralAllocator_ptr self, void* p, uintptr_t newsize, uintptr_t oldsize);
typedef struct nlniltype {} nlniltype;
static nelua_span_GCItem nelua_GeneralAllocator_spanalloc0__1(nelua_GeneralAllocator_ptr self, nlniltype T, uintptr_t size);
static nelua_span_GCItem nelua_GeneralAllocator_spanrealloc__1(nelua_GeneralAllocator_ptr self, nelua_span_GCItem s, uintptr_t size);
static void nelua_GeneralAllocator_spandealloc__1(nelua_GeneralAllocator_ptr self, nelua_span_GCItem s);
static nelua_GeneralAllocator nelua_general_allocator = {};
#include <setjmp.h>
static nelua_GeneralAllocator nelua_allocator = {};
typedef struct nelua_GC nelua_GC;
struct nelua_GC {
  void* bottom;
  bool stopped;
  uintptr_t minptr;
  uintptr_t maxptr;
  nelua_span_GCItem items;
  nelua_span_GCItem frees;
  double loadfactor;
  double sweepfactor;
  uintptr_t nitems;
  uintptr_t nslots;
  uintptr_t mitems;
  uintptr_t nfrees;
  uintptr_t membytes;
};
nelua_static_assert(sizeof(nelua_GC) == 120, "Nelua and C disagree on type size");
static nelua_GC nelua_gc = {0};
typedef nelua_GC* nelua_GC_ptr;
static uintptr_t nelua_GC__hash(nelua_GC_ptr self, void* ptr);
static uintptr_t nelua_GC__probe(nelua_GC_ptr self, uintptr_t i, uintptr_t h);
static nelua_GCItem_ptr nelua_GC__get_ptr(nelua_GC_ptr self, void* ptr);
static void nelua_assert(bool cond);
static void nelua_GC__add_ptr(nelua_GC_ptr self, void* ptr, uintptr_t size, uintptr_t flags, nelua_FinalizerCallback finalizer, bool rehash);
static void nelua_GC__remove_ptr(nelua_GC_ptr self, void* ptr);
typedef struct {uintptr_t data[24];} nlusize_arr24;
nelua_static_assert(sizeof(nlusize_arr24) == 192, "Nelua and C disagree on type size");
static nlusize_arr24 nelua_GC_primes = {{0U, 1U, 5U, 11U, 23U, 53U, 101U, 197U, 389U, 683U, 1259U, 2417U, 4733U, 9371U, 18617U, 37097U, 74093U, 148073U, 296099U, 592019U, 1100009U, 2200013U, 4400021U, 8800019U}};
static uintptr_t nelua_GC__ideal_size(nelua_GC_ptr self, uintptr_t size);
#define NLNIL (nlniltype){}
static bool nelua_GC__rehash(nelua_GC_ptr self, uintptr_t newsize);
static bool nelua_GC__resize_more(nelua_GC_ptr self);
static bool nelua_GC__resize_less(nelua_GC_ptr self);
#define nelua_noinline __attribute__((noinline))
static nelua_noinline void nelua_GC__unmark_all(nelua_GC_ptr self);
typedef void** nlpointer_arr0_ptr;
static nelua_noinline __attribute__((no_sanitize_memory)) void nelua_GC__mark_ptr(nelua_GC_ptr self, void* ptr);
typedef void** nlpointer_ptr;
static nelua_noinline __attribute__((no_sanitize_address)) void nelua_GC__mark_stack(nelua_GC_ptr self);
static nelua_noinline void nelua_GC__mark(nelua_GC_ptr self);
static nelua_noinline void nelua_GC__sweep(nelua_GC_ptr self);
static void nelua_GC__mark_statics(nelua_GC_ptr self);
static void nelua_GC_init(nelua_GC_ptr self, void* stack);
static void nelua_GC_terminate(nelua_GC_ptr self);
static void nelua_GC_stop(nelua_GC_ptr self);
static void nelua_GC_restart(nelua_GC_ptr self);
static bool nelua_GC_isrunning(nelua_GC_ptr self);
static double nelua_GC_count(nelua_GC_ptr self);
static void nelua_GC_collect(nelua_GC_ptr self);
static bool nelua_GC_add(nelua_GC_ptr self, void* ptr, uintptr_t size, uintptr_t flags, nelua_FinalizerCallback finalizer);
static void nelua_GC_remove(nelua_GC_ptr self, void* ptr);
static inline void* nelua_GC__alloc(nelua_GC_ptr self, void* ptr, uintptr_t size, uintptr_t flags, nelua_FinalizerCallback finalizer);
static void* nelua_GC_alloc_opt(nelua_GC_ptr self, uintptr_t size, uintptr_t flags, nelua_FinalizerCallback finalizer);
static void* nelua_GC_alloc0_opt(nelua_GC_ptr self, uintptr_t size, uintptr_t flags, nelua_FinalizerCallback finalizer);
static void* nelua_GC_alloc(nelua_GC_ptr self, uintptr_t size);
static void* nelua_GC_alloc0(nelua_GC_ptr self, uintptr_t size);
static inline void* nelua_GC__realloc(nelua_GC_ptr self, void* qtr, void* ptr, uintptr_t size);
static void* nelua_GC_realloc(nelua_GC_ptr self, void* ptr, uintptr_t size, uintptr_t oldsize);
static void* nelua_GC_realloc0(nelua_GC_ptr self, void* ptr, uintptr_t size, uintptr_t oldsize);
static void nelua_GC_dealloc(nelua_GC_ptr self, void* ptr);
typedef char** nlcstring_ptr;
int main(int argc, nlcstring_ptr argv);
typedef struct nelua_GCAllocator nelua_GCAllocator;
typedef nelua_GCAllocator* nelua_GCAllocator_ptr;
struct nelua_GCAllocator {
};
nelua_static_assert(sizeof(nelua_GCAllocator) == 0, "Nelua and C disagree on type size");
static void* nelua_GCAllocator_alloc(nelua_GCAllocator_ptr self, uintptr_t size);
static void* nelua_GCAllocator_alloc0(nelua_GCAllocator_ptr self, uintptr_t size);
static void* nelua_GCAllocator_realloc(nelua_GCAllocator_ptr self, void* p, uintptr_t size, uintptr_t oldsize);
static void* nelua_GCAllocator_realloc0(nelua_GCAllocator_ptr self, void* p, uintptr_t newsize, uintptr_t oldsize);
static void nelua_GCAllocator_dealloc(nelua_GCAllocator_ptr self, void* p);
static bug_span_int64 nelua_GCAllocator_spanrealloc0__1(nelua_GCAllocator_ptr self, bug_span_int64 s, uintptr_t size);
static bug_span_Color nelua_GCAllocator_spanrealloc0__2(nelua_GCAllocator_ptr self, bug_span_Color s, uintptr_t size);
static void nelua_GCAllocator_spandealloc__1(nelua_GCAllocator_ptr self, bug_span_int64 s);
static void nelua_GCAllocator_spandealloc__2(nelua_GCAllocator_ptr self, bug_span_Color s);
static nelua_GCAllocator nelua_gc_allocator = {};
static nelua_GCAllocator_ptr nelua_default_allocator = NULL;
typedef struct bug_sequence_int64 bug_sequence_int64;
typedef bug_sequence_int64* bug_sequence_int64_ptr;
typedef struct bug_sequenceimpl_int64 bug_sequenceimpl_int64;
typedef bug_sequenceimpl_int64* bug_sequenceimpl_int64_ptr;
struct bug_sequenceimpl_int64 {
  uintptr_t size;
  bug_span_int64 data;
};
nelua_static_assert(sizeof(bug_sequenceimpl_int64) == 24, "Nelua and C disagree on type size");
struct bug_sequence_int64 {
  bug_sequenceimpl_int64_ptr impl;
  nelua_GCAllocator allocator;
};
nelua_static_assert(sizeof(bug_sequence_int64) == 8, "Nelua and C disagree on type size");
static char __strlit9[29] = "sequence.grow: out of memory";
static void bug_sequence_int64__grow(bug_sequence_int64_ptr self);
static char __strlit10[29] = "sequence.init: out of memory";
static inline void bug_sequence_int64_init(bug_sequence_int64_ptr self);
static void bug_sequence_int64_clear(bug_sequence_int64_ptr self);
static void bug_sequence_int64_destroy(bug_sequence_int64_ptr self);
static char __strlit11[32] = "sequence.reserve: out of memory";
static void bug_sequence_int64_reserve(bug_sequence_int64_ptr self, uintptr_t n);
static void bug_sequence_int64_resize(bug_sequence_int64_ptr self, uintptr_t n);
static inline void bug_sequence_int64_push(bug_sequence_int64_ptr self, int64_t v);
static char __strlit12[26] = "sequence.pop: length is 0";
static inline int64_t bug_sequence_int64_pop(bug_sequence_int64_ptr self);
static char __strlit13[40] = "sequence.insert: position out of bounds";
static void bug_sequence_int64_insert(bug_sequence_int64_ptr self, uintptr_t pos, int64_t v);
static char __strlit14[40] = "sequence.remove: position out of bounds";
static int64_t bug_sequence_int64_remove(bug_sequence_int64_ptr self, uintptr_t pos);
static bool bug_sequence_int64_remove_value(bug_sequence_int64_ptr self, int64_t v);
static inline intptr_t bug_sequence_int64_capacity(bug_sequence_int64_ptr self);
static char __strlit15[43] = "sequence.__atindex: position out of bounds";
static inline nlint64_ptr bug_sequence_int64___atindex(bug_sequence_int64_ptr self, uintptr_t i);
static inline intptr_t bug_sequence_int64___len(bug_sequence_int64_ptr self);
typedef struct bug_sequence_Color bug_sequence_Color;
typedef bug_sequence_Color* bug_sequence_Color_ptr;
typedef struct bug_sequenceimpl_Color bug_sequenceimpl_Color;
typedef bug_sequenceimpl_Color* bug_sequenceimpl_Color_ptr;
struct bug_sequenceimpl_Color {
  uintptr_t size;
  bug_span_Color data;
};
nelua_static_assert(sizeof(bug_sequenceimpl_Color) == 24, "Nelua and C disagree on type size");
struct bug_sequence_Color {
  bug_sequenceimpl_Color_ptr impl;
  nelua_GCAllocator allocator;
};
nelua_static_assert(sizeof(bug_sequence_Color) == 8, "Nelua and C disagree on type size");
static void bug_sequence_Color__grow(bug_sequence_Color_ptr self);
static inline void bug_sequence_Color_init(bug_sequence_Color_ptr self);
static void bug_sequence_Color_clear(bug_sequence_Color_ptr self);
static void bug_sequence_Color_destroy(bug_sequence_Color_ptr self);
static void bug_sequence_Color_reserve(bug_sequence_Color_ptr self, uintptr_t n);
static void bug_sequence_Color_resize(bug_sequence_Color_ptr self, uintptr_t n);
static inline void bug_sequence_Color_push(bug_sequence_Color_ptr self, Color v);
static inline Color bug_sequence_Color_pop(bug_sequence_Color_ptr self);
static void bug_sequence_Color_insert(bug_sequence_Color_ptr self, uintptr_t pos, Color v);
static Color bug_sequence_Color_remove(bug_sequence_Color_ptr self, uintptr_t pos);
static bool nelua_eq_Color(Color a, Color b);
static bool bug_sequence_Color_remove_value(bug_sequence_Color_ptr self, Color v);
static inline intptr_t bug_sequence_Color_capacity(bug_sequence_Color_ptr self);
static inline Color_ptr bug_sequence_Color___atindex(bug_sequence_Color_ptr self, uintptr_t i);
static inline intptr_t bug_sequence_Color___len(bug_sequence_Color_ptr self);
#include <raylib.h>
typedef unsigned char* nlcuchar_arr0_ptr;
typedef unsigned int* nlcuint_ptr;
typedef char** nlcstring_arr0_ptr;
typedef int* nlcint_ptr;
typedef Camera3D* Camera3D_ptr;
typedef Vector2* Vector2_arr0_ptr;
typedef Vector2* Vector2_ptr;
typedef Vector4* Vector4_arr0_ptr;
typedef Image* Image_ptr;
typedef Texture2D* Texture2D_ptr;
typedef int* nlcint_arr0_ptr;
typedef CharInfo* CharInfo_arr0_ptr;
typedef Rectangle* Rectangle_arr0_ptr;
typedef Rectangle_arr0_ptr* Rectangle_arr0_ptr_ptr;
typedef Mesh* Mesh_arr0_ptr;
typedef Material* Material_arr0_ptr;
typedef Material* Material_ptr;
typedef Model* Model_ptr;
typedef ModelAnimation* ModelAnimation_arr0_ptr;
typedef Mesh* Mesh_ptr;
typedef Vector3* Vector3_ptr;
typedef Wave* Wave_ptr;
typedef float* nlfloat32_arr0_ptr;
#include <raymath.h>
typedef float* nlfloat32_ptr;
static int nelua_main(int nelua_argc, char** nelua_argv);
/* ------------------------------ DEFINITIONS ------------------------------- */
void nelua_panic_stringview(nlstringview s) {
  if(s.data && s.size > 0) {
    fprintf(stderr, "%s\n", (char*)s.data);
  }
  abort();
}
inline void nelua_assert_stringview(bool cond, nlstringview s) {
  if(nelua_unlikely(!cond)) {
    nelua_panic_stringview(s);
  }
}
void nelua_memory_copy(void* dest, void* src, uintptr_t size) {
  nelua_assert_stringview((dest && src), ((nlstringview){(uint8_t*)__strlit1, 28}));
  memcpy(dest, src, (size_t)size);
}
void nelua_memory_move(void* dest, void* src, uintptr_t size) {
  nelua_assert_stringview((dest && src), ((nlstringview){(uint8_t*)__strlit2, 28}));
  memmove(dest, src, (size_t)size);
}
void nelua_memory_set(void* dest, uint8_t x, uintptr_t size) {
  nelua_assert_stringview(dest != NULL, ((nlstringview){(uint8_t*)__strlit3, 27}));
  memset(dest, (int)x, (size_t)size);
}
void nelua_memory_zero(void* dest, uintptr_t size) {
  nelua_assert_stringview(dest != NULL, ((nlstringview){(uint8_t*)__strlit4, 28}));
  memset(dest, 0, (size_t)size);
}
int32_t nelua_memory_compare(void* a, void* b, uintptr_t size) {
  nelua_assert_stringview((a && b), ((nlstringview){(uint8_t*)__strlit2, 28}));
  return (int32_t)memcmp(a, b, (size_t)size);
}
bool nelua_memory_equals(void* a, void* b, uintptr_t size) {
  nelua_assert_stringview((a && b), ((nlstringview){(uint8_t*)__strlit5, 30}));
  return (memcmp(a, b, (size_t)size) == 0);
}
void* nelua_memory_scan(void* p, uint8_t x, uintptr_t size) {
  nelua_assert_stringview(p != NULL, ((nlstringview){(uint8_t*)__strlit6, 28}));
  return memchr(p, (int)x, (size_t)size);
}
void nelua_panic_cstring(char *s) {
  fprintf(stderr, "%s\n", s);
  abort();
}
inline nluint8_ptr nelua_assert_deref_nluint8_ptr(nluint8_ptr p) {
  if(nelua_unlikely(p == NULL)) {
    nelua_panic_cstring("attempt to dereference a null pointer");
  }
  return p;
}
void* nelua_memory_find(void* haystack, uintptr_t haystacksize, void* needle, uintptr_t needlesize) {
  if(nelua_unlikely(((needlesize == 0U) || (haystack == needle)))) {
    return haystack;
  } else if(nelua_unlikely((needlesize > haystacksize))) {
    return NULL;
  } else {
    nelua_assert_stringview((haystack && needle), ((nlstringview){(uint8_t*)__strlit7, 28}));
    if(needlesize == 1U) {
      return memchr(haystack, (int)(*nelua_assert_deref_nluint8_ptr((nluint8_ptr)needle)), (size_t)haystacksize);
    }
    uintptr_t haystackbegin = (uintptr_t)haystack;
    for(uintptr_t i = haystackbegin, __end = (haystackbegin + (haystacksize - needlesize)); i <= __end; i = i + 1) {
      void* p = (void*)i;
      if(memcmp(p, needle, (size_t)needlesize) == 0) {
        return p;
      }
    }
    return NULL;
  }
}
nelua_GCItem_ptr nelua_span_GCItem___atindex(nelua_span_GCItem_ptr self, uintptr_t i) {
  return (&(self->data)[i]);
}
intptr_t nelua_span_GCItem___len(nelua_span_GCItem_ptr self) {
  return (intptr_t)self->size;
}
nlint64_ptr bug_span_int64___atindex(bug_span_int64_ptr self, uintptr_t i) {
  nelua_assert_stringview((i < self->size), ((nlstringview){(uint8_t*)__strlit8, 34}));
  return (&(self->data)[i]);
}
intptr_t bug_span_int64___len(bug_span_int64_ptr self) {
  return (intptr_t)self->size;
}
Color_ptr bug_span_Color___atindex(bug_span_Color_ptr self, uintptr_t i) {
  nelua_assert_stringview((i < self->size), ((nlstringview){(uint8_t*)__strlit8, 34}));
  return (&(self->data)[i]);
}
intptr_t bug_span_Color___len(bug_span_Color_ptr self) {
  return (intptr_t)self->size;
}
int64_t nelua_memory_moveval__1(nlint64_ptr a) {
  int64_t ret;
  memcpy((void*)(&ret), (void*)a, 8U);
  memset((void*)a, 0, 8U);
  return ret;
}
Color nelua_memory_moveval__2(Color_ptr a) {
  Color ret;
  memcpy((void*)(&ret), (void*)a, 4U);
  memset((void*)a, 0, 4U);
  return ret;
}
void nelua_memory_swapval__1(nlint64_ptr a, nlint64_ptr b) {
  nluint8_arr8 tmp;
  memcpy((void*)(&tmp.data[0]), (void*)a, 8U);
  memcpy((void*)a, (void*)b, 8U);
  memcpy((void*)b, (void*)(&tmp.data[0]), 8U);
}
void nelua_memory_swapval__2(Color_ptr a, Color_ptr b) {
  nluint8_arr4 tmp;
  memcpy((void*)(&tmp.data[0]), (void*)a, 4U);
  memcpy((void*)a, (void*)b, 4U);
  memcpy((void*)b, (void*)(&tmp.data[0]), 4U);
}
void* nelua_GeneralAllocator_alloc(nelua_GeneralAllocator_ptr self, uintptr_t size) {
  if(nelua_unlikely((size == 0U))) {
    return NULL;
  }
  return malloc((size_t)size);
}
void* nelua_GeneralAllocator_alloc0(nelua_GeneralAllocator_ptr self, uintptr_t size) {
  if(nelua_unlikely((size == 0U))) {
    return NULL;
  }
  return calloc((size_t)size, (size_t)1U);
}
void* nelua_GeneralAllocator_realloc(nelua_GeneralAllocator_ptr self, void* p, uintptr_t newsize, uintptr_t oldsize) {
  if(nelua_unlikely((newsize == 0U))) {
    if(nelua_likely((p != NULL))) {
      free(p);
    }
    return NULL;
  } else if(nelua_unlikely((newsize == oldsize))) {
    return p;
  }
  return realloc(p, (size_t)newsize);
}
void nelua_GeneralAllocator_dealloc(nelua_GeneralAllocator_ptr self, void* p) {
  if(nelua_unlikely((p == NULL))) {
    return;
  }
  free(p);
}
void* nelua_GeneralAllocator_realloc0(nelua_GeneralAllocator_ptr self, void* p, uintptr_t newsize, uintptr_t oldsize) {
  p = nelua_GeneralAllocator_realloc(self, p, newsize, oldsize);
  if(nelua_likely(((newsize > oldsize) && (p != NULL)))) {
    memset((void*)(&(((nluint8_arr0_ptr)p))[oldsize]), 0, (size_t)(newsize - oldsize));
  }
  return p;
}
nelua_span_GCItem nelua_GeneralAllocator_spanalloc0__1(nelua_GeneralAllocator_ptr self, nlniltype T, uintptr_t size) {
  nelua_span_GCItem s = {0};
  if(nelua_likely((size > 0))) {
    s.data = ((nelua_GCItem_arr0_ptr)nelua_GeneralAllocator_alloc0(self, (size * 40)));
    s.size = size;
  }
  return s;
}
nelua_span_GCItem nelua_GeneralAllocator_spanrealloc__1(nelua_GeneralAllocator_ptr self, nelua_span_GCItem s, uintptr_t size) {
  nelua_GCItem_arr0_ptr p = ((nelua_GCItem_arr0_ptr)nelua_GeneralAllocator_realloc(self, (void*)s.data, (size * 40), s.size));
  if(nelua_unlikely(((size > 0) && (p == NULL)))) {
    return s;
  }
  s.data = p;
  s.size = size;
  return s;
}
void nelua_GeneralAllocator_spandealloc__1(nelua_GeneralAllocator_ptr self, nelua_span_GCItem s) {
  if(nelua_unlikely((s.size == 0U))) {
    return;
  }
  nelua_GeneralAllocator_dealloc(self, (void*)s.data);
}
uintptr_t nelua_GC__hash(nelua_GC_ptr self, void* ptr) {
  return ((uintptr_t)ptr >> 3);
}
uintptr_t nelua_GC__probe(nelua_GC_ptr self, uintptr_t i, uintptr_t h) {
  intptr_t v = ((intptr_t)i - ((intptr_t)h - (intptr_t)1));
  if(v < 0) {
    v = ((intptr_t)self->nslots + v);
  }
  return (uintptr_t)v;
}
nelua_GCItem_ptr nelua_GC__get_ptr(nelua_GC_ptr self, void* ptr) {
  if(self->nslots == 0U) {
    return NULL;
  }
  uintptr_t i = (nelua_GC__hash(self, ptr) % self->nslots);
  uintptr_t j = (uintptr_t)0U;
  while(true) {
    uintptr_t h = (*nelua_span_GCItem___atindex(&self->items, i)).hash;
    if((h == 0U) || (j > nelua_GC__probe(self, i, h))) {
      return NULL;
    }
    if((*nelua_span_GCItem___atindex(&self->items, i)).ptr == ptr) {
      return (&(*nelua_span_GCItem___atindex(&self->items, i)));
    }
    i = ((i + 1) % self->nslots);
    j = (j + 1);
  }
  return NULL;
}
inline void nelua_assert(bool cond) {
  if(nelua_unlikely(!cond)) {
    nelua_panic_cstring("assertion failed!");
  }
}
void nelua_GC__add_ptr(nelua_GC_ptr self, void* ptr, uintptr_t size, uintptr_t flags, nelua_FinalizerCallback finalizer, bool rehash) {
  nelua_assert((self->nslots > 0));
  uintptr_t i = (nelua_GC__hash(self, ptr) % self->nslots);
  nelua_GCItem item = ({
    nelua_GCItem __rec = {0};
    __rec.ptr = ptr;
    __rec.flags = flags;
    __rec.size = size;
    __rec.hash = (i + 1);
    __rec.finalizer = finalizer;
    __rec;
  });
  uintptr_t j = (uintptr_t)0U;
  while(true) {
    uintptr_t h = (*nelua_span_GCItem___atindex(&self->items, i)).hash;
    if(h == 0U) {
      (*nelua_span_GCItem___atindex(&self->items, i)) = item;
      if((!rehash) && ((flags & 2U) == 0U)) {
        self->membytes = (self->membytes + size);
      }
      return;
    }
    if((*nelua_span_GCItem___atindex(&self->items, i)).ptr == item.ptr) {
      return;
    }
    uintptr_t p = nelua_GC__probe(self, i, h);
    if(j >= p) {
      nelua_GCItem __asgntmp1 = item;
      nelua_GCItem __asgntmp2 = (*nelua_span_GCItem___atindex(&self->items, i));
      (*nelua_span_GCItem___atindex(&self->items, i)) = __asgntmp1;
      item = __asgntmp2;
      j = p;
    }
    i = ((i + 1) % self->nslots);
    j = (j + 1);
  }
}
void nelua_GC__remove_ptr(nelua_GC_ptr self, void* ptr) {
  if(self->nitems == 0U) {
    return;
  }
  for(uintptr_t i = 0U, __end = self->nfrees; i < __end; i = i + 1) {
    if((*nelua_span_GCItem___atindex(&self->frees, i)).ptr == ptr) {
      (*nelua_span_GCItem___atindex(&self->frees, i)).ptr = NULL;
    }
  }
  uintptr_t i = (nelua_GC__hash(self, ptr) % self->nslots);
  uintptr_t j = (uintptr_t)0U;
  while(true) {
    nelua_GCItem_ptr item = (&(*nelua_span_GCItem___atindex(&self->items, i)));
    uintptr_t h = item->hash;
    if((h == 0U) || (j > nelua_GC__probe(self, i, h))) {
      return;
    }
    if(item->ptr == ptr) {
      if((item->flags & 2U) == 0U) {
        self->membytes = (self->membytes - item->size);
      }
      memset((void*)item, 0, 40U);
      j = i;
      while(true) {
        uintptr_t nj = ((j + 1) % self->nslots);
        uintptr_t nh = (*nelua_span_GCItem___atindex(&self->items, nj)).hash;
        if((nh != 0U) && (nelua_GC__probe(self, nj, nh) > 0)) {
          {
            nelua_GCItem_ptr __tmp1 = (&(*nelua_span_GCItem___atindex(&self->items, j)));
            nelua_GCItem_ptr __tmp2 = (&(*nelua_span_GCItem___atindex(&self->items, nj)));
            memcpy((void*)__tmp1, (void*)__tmp2, 40U);
          };
          memset((void*)(&(*nelua_span_GCItem___atindex(&self->items, nj))), 0, 40U);
          j = nj;
        } else {
          break;
        }
      }
      self->nitems = (self->nitems - 1);
      return;
    }
    i = ((i + 1) % self->nslots);
    j = (j + 1);
  }
}
uintptr_t nelua_GC__ideal_size(nelua_GC_ptr self, uintptr_t size) {
  size = (uintptr_t)((size + 1) / self->loadfactor);
  for(uintptr_t i = 0U; i < 24U; i = i + 1) {
    if(nelua_GC_primes.data[i] >= size) {
      return nelua_GC_primes.data[i];
    }
  }
  uintptr_t last = nelua_GC_primes.data[23];
  uintptr_t i = (uintptr_t)0U;
  while(true) {
    if((last * i) >= size) {
      return (last * i);
    }
    i = (i + 1);
  }
  return 0U;
}
bool nelua_GC__rehash(nelua_GC_ptr self, uintptr_t newsize) {
  nelua_span_GCItem olditems = self->items;
  uintptr_t oldsize = self->nslots;
  self->nslots = newsize;
  self->items = nelua_GeneralAllocator_spanalloc0__1(&nelua_allocator, NLNIL, self->nslots);
  if(self->items.size == 0U) {
    self->nslots = oldsize;
    self->items = olditems;
    return false;
  }
  for(uintptr_t i = 0U, __end = oldsize; i < __end; i = i + 1) {
    nelua_GCItem_ptr olditem = (&(*nelua_span_GCItem___atindex(&olditems, i)));
    if(olditem->hash != 0U) {
      nelua_GC__add_ptr(self, olditem->ptr, olditem->size, olditem->flags, olditem->finalizer, true);
    }
  }
  nelua_GeneralAllocator_spandealloc__1(&nelua_allocator, olditems);
  return true;
}
bool nelua_GC__resize_more(nelua_GC_ptr self) {
  uintptr_t newsize = nelua_GC__ideal_size(self, self->nitems);
  uintptr_t oldsize = self->nslots;
  if(newsize > oldsize) {
    return nelua_GC__rehash(self, newsize);
  } else {
    return true;
  }
}
bool nelua_GC__resize_less(nelua_GC_ptr self) {
  uintptr_t newsize = nelua_GC__ideal_size(self, self->nitems);
  uintptr_t oldsize = self->nslots;
  if(newsize < oldsize) {
    return nelua_GC__rehash(self, newsize);
  } else {
    return true;
  }
}
void nelua_GC__unmark_all(nelua_GC_ptr self) {
  for(uintptr_t i = 0U, __end = self->nslots; i < __end; i = i + 1) {
    (*nelua_span_GCItem___atindex(&self->items, i)).flags = ((*nelua_span_GCItem___atindex(&self->items, i)).flags & 18446744073709551614U);
  }
}
void nelua_GC__mark_ptr(nelua_GC_ptr self, void* ptr) {
  if(((uintptr_t)ptr < self->minptr) || ((uintptr_t)ptr > self->maxptr)) {
    return;
  }
  uintptr_t i = (nelua_GC__hash(self, ptr) % self->nslots);
  uintptr_t j = (uintptr_t)0U;
  while(true) {
    uintptr_t h = (*nelua_span_GCItem___atindex(&self->items, i)).hash;
    if((h == 0U) || (j > nelua_GC__probe(self, i, h))) {
      return;
    }
    if(ptr == (*nelua_span_GCItem___atindex(&self->items, i)).ptr) {
      if(((*nelua_span_GCItem___atindex(&self->items, i)).flags & 1U) != 0U) {
        return;
      }
      (*nelua_span_GCItem___atindex(&self->items, i)).flags = ((*nelua_span_GCItem___atindex(&self->items, i)).flags | 1U);
      if(((*nelua_span_GCItem___atindex(&self->items, i)).flags & 4U) != 0U) {
        return;
      }
      for(uintptr_t k = 0U, __end = ((*nelua_span_GCItem___atindex(&self->items, i)).size / 8); k < __end; k = k + 1) {
        nelua_GC__mark_ptr(self, (((nlpointer_arr0_ptr)(*nelua_span_GCItem___atindex(&self->items, i)).ptr))[k]);
      }
      return;
    }
    i = ((i + 1) % self->nslots);
    j = (j + 1);
  }
}
void nelua_GC__mark_stack(nelua_GC_ptr self) {
  void* stk = NULL;
  uintptr_t bot = (uintptr_t)self->bottom;
  uintptr_t top = (uintptr_t)(&stk);
  if(bot < top) {
    uintptr_t __asgntmp3 = top;
    uintptr_t __asgntmp4 = bot;
    bot = __asgntmp3;
    top = __asgntmp4;
  }
  for(uintptr_t pi = top, __end = bot; pi <= __end; pi = pi + 8) {
    nelua_GC__mark_ptr(self, (*(nlpointer_ptr)pi));
  }
}
void nelua_GC__mark(nelua_GC_ptr self) {
  if(self->nitems == 0U) {
    return;
  }
  nelua_GC__unmark_all(self);
  for(uintptr_t i = 0U, __end = self->nslots; i < __end; i = i + 1) {
    if(((*nelua_span_GCItem___atindex(&self->items, i)).hash == 0U) || (((*nelua_span_GCItem___atindex(&self->items, i)).flags & 1U) != 0U)) {
      continue;
    }
    if(((*nelua_span_GCItem___atindex(&self->items, i)).flags & 2U) != 0U) {
      (*nelua_span_GCItem___atindex(&self->items, i)).flags = ((*nelua_span_GCItem___atindex(&self->items, i)).flags | 1U);
      if(((*nelua_span_GCItem___atindex(&self->items, i)).flags & 4U) != 0U) {
        continue;
      }
      for(uintptr_t k = 0U, __end = ((*nelua_span_GCItem___atindex(&self->items, i)).size / 8U); k < __end; k = k + 1) {
        nelua_GC__mark_ptr(self, (((nlpointer_arr0_ptr)(*nelua_span_GCItem___atindex(&self->items, i)).ptr))[k]);
      }
    }
  }
  jmp_buf env = {0};
  setjmp(env);
  nelua_GC__mark_stack(self);
}
void nelua_GC__sweep(nelua_GC_ptr self) {
  if(self->nitems == 0U) {
    return;
  }
  self->nfrees = (uintptr_t)0U;
  for(uintptr_t j = 0U, __end = self->nslots; j < __end; j = j + 1) {
    if(!((((*nelua_span_GCItem___atindex(&self->items, j)).hash == 0U) || (((*nelua_span_GCItem___atindex(&self->items, j)).flags & 1U) != 0U)) || (((*nelua_span_GCItem___atindex(&self->items, j)).flags & 2U) != 0U))) {
      self->nfrees = (self->nfrees + 1);
    }
  }
  self->frees = nelua_GeneralAllocator_spanrealloc__1(&nelua_allocator, self->frees, self->nfrees);
  if(self->frees.size != self->nfrees) {
    return;
  }
  uintptr_t i = (uintptr_t)0U;
  uintptr_t k = (uintptr_t)0U;
  while(i < self->nslots) {
    if((((*nelua_span_GCItem___atindex(&self->items, i)).hash == 0U) || (((*nelua_span_GCItem___atindex(&self->items, i)).flags & 1U) != 0U)) || (((*nelua_span_GCItem___atindex(&self->items, i)).flags & 2U) != 0U)) {
      i = (i + 1);
      continue;
    }
    nelua_GCItem_ptr item = (&(*nelua_span_GCItem___atindex(&self->items, i)));
    (*nelua_span_GCItem___atindex(&self->frees, k)) = (*item);
    k = (k + 1);
    if((item->flags & 2U) == 0U) {
      self->membytes = (self->membytes - item->size);
    }
    memset((void*)item, 0, 40U);
    uintptr_t j = i;
    while(true) {
      uintptr_t nj = ((j + 1) % self->nslots);
      uintptr_t nh = (*nelua_span_GCItem___atindex(&self->items, nj)).hash;
      if((nh != 0U) && (nelua_GC__probe(self, nj, nh) > 0)) {
        {
          nelua_GCItem_ptr __tmp1 = (&(*nelua_span_GCItem___atindex(&self->items, j)));
          nelua_GCItem_ptr __tmp2 = (&(*nelua_span_GCItem___atindex(&self->items, nj)));
          memcpy((void*)__tmp1, (void*)__tmp2, 40U);
        };
        memset((void*)(&(*nelua_span_GCItem___atindex(&self->items, nj))), 0, 40U);
        j = nj;
      } else {
        break;
      }
    }
    self->nitems = (self->nitems - 1);
  }
  nelua_GC__resize_less(self);
  self->mitems = ((self->nitems + (uintptr_t)(self->nitems * self->sweepfactor)) + 1);
  for(uintptr_t j = 0U, __end = self->nfrees; j < __end; j = j + 1) {
    if((*nelua_span_GCItem___atindex(&self->frees, j)).ptr != NULL) {
      if((*nelua_span_GCItem___atindex(&self->frees, j)).finalizer != NULL) {
        (*nelua_span_GCItem___atindex(&self->frees, j)).finalizer((*nelua_span_GCItem___atindex(&self->frees, j)).ptr);
      }
      nelua_GeneralAllocator_dealloc(&nelua_allocator, (*nelua_span_GCItem___atindex(&self->frees, j)).ptr);
    }
  }
  nelua_GeneralAllocator_spandealloc__1(&nelua_allocator, self->frees);
  self->frees = (nelua_span_GCItem){0};
  self->nfrees = (uintptr_t)0U;
}
void nelua_GC__mark_statics(nelua_GC_ptr self) {
  nelua_GC_add(&nelua_gc, (void*)(&nelua_default_allocator), 8U, 2U, (nelua_FinalizerCallback)NULL);
}
void nelua_GC_init(nelua_GC_ptr self, void* stack) {
  (*self) = (nelua_GC){0};
  self->bottom = stack;
  self->stopped = false;
  self->minptr = 18446744073709551615U;
  self->loadfactor = 0.9;
  self->sweepfactor = 0.5;
  nelua_GC__mark_statics(self);
}
void nelua_GC_terminate(nelua_GC_ptr self) {
  nelua_GC__unmark_all(self);
  nelua_GC__sweep(self);
  nelua_GeneralAllocator_spandealloc__1(&nelua_allocator, self->items);
  nelua_GeneralAllocator_spandealloc__1(&nelua_allocator, self->frees);
  (*self) = (nelua_GC){0};
  self->stopped = true;
}
void nelua_GC_stop(nelua_GC_ptr self) {
  self->stopped = true;
}
void nelua_GC_restart(nelua_GC_ptr self) {
  self->stopped = false;
}
bool nelua_GC_isrunning(nelua_GC_ptr self) {
  return (!self->stopped);
}
double nelua_GC_count(nelua_GC_ptr self) {
  return (self->membytes / 1024.0);
}
void nelua_GC_collect(nelua_GC_ptr self) {
  nelua_GC__mark(self);
  nelua_GC__sweep(self);
}
bool nelua_GC_add(nelua_GC_ptr self, void* ptr, uintptr_t size, uintptr_t flags, nelua_FinalizerCallback finalizer) {
  self->nitems = (self->nitems + 1);
  uintptr_t uptr = (uintptr_t)ptr;
  if((uptr + size) > self->maxptr) {
    self->maxptr = (uptr + size);
  }
  if(uptr < self->minptr) {
    self->minptr = uptr;
  }
  if(nelua_GC__resize_more(self)) {
    nelua_GC__add_ptr(self, ptr, size, flags, finalizer, false);
    if((!self->stopped) && (self->nitems > self->mitems)) {
      nelua_GC_collect(self);
    }
    return true;
  } else {
    self->nitems = (self->nitems - 1);
    return false;
  }
}
void nelua_GC_remove(nelua_GC_ptr self, void* ptr) {
  nelua_GC__remove_ptr(self, ptr);
  nelua_GC__resize_less(self);
  self->mitems = ((self->nitems + (self->nitems / 2)) + 1);
}
void* nelua_GC__alloc(nelua_GC_ptr self, void* ptr, uintptr_t size, uintptr_t flags, nelua_FinalizerCallback finalizer) {
  if(ptr != NULL) {
    if(!nelua_GC_add(self, ptr, size, flags, finalizer)) {
      nelua_GeneralAllocator_dealloc(&nelua_allocator, ptr);
      ptr = NULL;
    }
  }
  return ptr;
}
void* nelua_GC_alloc_opt(nelua_GC_ptr self, uintptr_t size, uintptr_t flags, nelua_FinalizerCallback finalizer) {
  void* ptr = nelua_GeneralAllocator_alloc(&nelua_allocator, size);
  return nelua_GC__alloc(self, ptr, size, flags, finalizer);
}
void* nelua_GC_alloc0_opt(nelua_GC_ptr self, uintptr_t size, uintptr_t flags, nelua_FinalizerCallback finalizer) {
  void* ptr = nelua_GeneralAllocator_alloc0(&nelua_allocator, size);
  return nelua_GC__alloc(self, ptr, size, flags, finalizer);
}
void* nelua_GC_alloc(nelua_GC_ptr self, uintptr_t size) {
  return nelua_GC_alloc_opt(self, size, 0U, (nelua_FinalizerCallback)NULL);
}
void* nelua_GC_alloc0(nelua_GC_ptr self, uintptr_t size) {
  return nelua_GC_alloc0_opt(self, size, 0U, (nelua_FinalizerCallback)NULL);
}
void* nelua_GC__realloc(nelua_GC_ptr self, void* qtr, void* ptr, uintptr_t size) {
  if(!qtr) {
    nelua_GC_remove(self, ptr);
    return NULL;
  }
  if(!ptr) {
    if(!nelua_GC_add(self, qtr, size, 0U, (nelua_FinalizerCallback)NULL)) {
      nelua_GeneralAllocator_dealloc(&nelua_allocator, qtr);
      qtr = NULL;
    }
    return qtr;
  }
  nelua_GCItem_ptr p = nelua_GC__get_ptr(self, ptr);
  if(p != NULL) {
    if(qtr == ptr) {
      p->size = size;
    } else {
      uintptr_t flags = p->flags;
      nelua_FinalizerCallback finalizer = p->finalizer;
      nelua_GC_remove(self, ptr);
      nelua_GC_add(self, qtr, size, flags, finalizer);
    }
    return qtr;
  }
  return NULL;
}
void* nelua_GC_realloc(nelua_GC_ptr self, void* ptr, uintptr_t size, uintptr_t oldsize) {
  void* qtr = nelua_GeneralAllocator_realloc(&nelua_allocator, ptr, size, oldsize);
  if(!qtr) {
    return NULL;
  }
  return nelua_GC__realloc(self, qtr, ptr, size);
}
void* nelua_GC_realloc0(nelua_GC_ptr self, void* ptr, uintptr_t size, uintptr_t oldsize) {
  void* qtr = nelua_GeneralAllocator_realloc0(&nelua_allocator, ptr, size, oldsize);
  if(!qtr) {
    return NULL;
  }
  return nelua_GC__realloc(self, qtr, ptr, size);
}
void nelua_GC_dealloc(nelua_GC_ptr self, void* ptr) {
  nelua_GCItem_ptr p = nelua_GC__get_ptr(self, ptr);
  if(p != NULL) {
    if(p->finalizer != NULL) {
      p->finalizer(ptr);
    }
    nelua_GeneralAllocator_dealloc(&nelua_allocator, ptr);
    nelua_GC_remove(self, ptr);
  }
}
int main(int argc, nlcstring_ptr argv) {
  nelua_GC_init(&nelua_gc, (void*)(&argc));
  int ret = nelua_main(argc, argv);
  nelua_GC_terminate(&nelua_gc);
  return ret;
}
void* nelua_GCAllocator_alloc(nelua_GCAllocator_ptr self, uintptr_t size) {
  return nelua_GC_alloc(&nelua_gc, size);
}
void* nelua_GCAllocator_alloc0(nelua_GCAllocator_ptr self, uintptr_t size) {
  return nelua_GC_alloc0(&nelua_gc, size);
}
void* nelua_GCAllocator_realloc(nelua_GCAllocator_ptr self, void* p, uintptr_t size, uintptr_t oldsize) {
  return nelua_GC_realloc(&nelua_gc, p, size, oldsize);
}
void* nelua_GCAllocator_realloc0(nelua_GCAllocator_ptr self, void* p, uintptr_t newsize, uintptr_t oldsize) {
  return nelua_GC_realloc0(&nelua_gc, p, newsize, oldsize);
}
void nelua_GCAllocator_dealloc(nelua_GCAllocator_ptr self, void* p) {
  nelua_GC_dealloc(&nelua_gc, p);
}
bug_span_int64 nelua_GCAllocator_spanrealloc0__1(nelua_GCAllocator_ptr self, bug_span_int64 s, uintptr_t size) {
  nlint64_arr0_ptr p = ((nlint64_arr0_ptr)nelua_GCAllocator_realloc0(self, (void*)s.data, (size * 8), (s.size * 8)));
  if(nelua_unlikely(((size > 0) && (p == NULL)))) {
    return s;
  }
  s.data = p;
  s.size = size;
  return s;
}
bug_span_Color nelua_GCAllocator_spanrealloc0__2(nelua_GCAllocator_ptr self, bug_span_Color s, uintptr_t size) {
  Color_arr0_ptr p = ((Color_arr0_ptr)nelua_GCAllocator_realloc0(self, (void*)s.data, (size * 4), (s.size * 4)));
  if(nelua_unlikely(((size > 0) && (p == NULL)))) {
    return s;
  }
  s.data = p;
  s.size = size;
  return s;
}
void nelua_GCAllocator_spandealloc__1(nelua_GCAllocator_ptr self, bug_span_int64 s) {
  if(nelua_unlikely((s.size == 0U))) {
    return;
  }
  nelua_GCAllocator_dealloc(self, (void*)s.data);
}
void nelua_GCAllocator_spandealloc__2(nelua_GCAllocator_ptr self, bug_span_Color s) {
  if(nelua_unlikely((s.size == 0U))) {
    return;
  }
  nelua_GCAllocator_dealloc(self, (void*)s.data);
}
void bug_sequence_int64__grow(bug_sequence_int64_ptr self) {
  uintptr_t cap = (uintptr_t)2U;
  if(nelua_likely((self->impl->data.size != 0U))) {
    cap = (self->impl->data.size * 2);
  }
  self->impl->data = nelua_GCAllocator_spanrealloc0__1(&self->allocator, self->impl->data, cap);
  nelua_assert_stringview((self->impl->data.size == cap), ((nlstringview){(uint8_t*)__strlit9, 28}));
}
void bug_sequence_int64_init(bug_sequence_int64_ptr self) {
  if(nelua_likely(self->impl != NULL)) {
    return;
  }
  self->impl = ((bug_sequenceimpl_int64_ptr)nelua_GCAllocator_alloc0(&self->allocator, 24U));
  nelua_assert_stringview((self->impl != NULL), ((nlstringview){(uint8_t*)__strlit10, 28}));
}
void bug_sequence_int64_clear(bug_sequence_int64_ptr self) {
  if(!self->impl) {
    return;
  }
  if(self->impl->data.size != 0U) {
    for(uintptr_t i = 0U, __end = self->impl->size; i <= __end; i = i + 1) {
      (*bug_span_int64___atindex(&self->impl->data, i)) = 0;
    }
  }
  self->impl->size = (uintptr_t)0U;
}
void bug_sequence_int64_destroy(bug_sequence_int64_ptr self) {
  if(!self->impl) {
    return;
  }
  bug_sequence_int64_clear(self);
  nelua_GCAllocator_spandealloc__1(&self->allocator, self->impl->data);
  self->impl->data = (bug_span_int64){0};
  nelua_GCAllocator_dealloc(&self->allocator, (void*)self->impl);
  self->impl = NULL;
}
void bug_sequence_int64_reserve(bug_sequence_int64_ptr self, uintptr_t n) {
  bug_sequence_int64_init(self);
  uintptr_t cap = (n + 1);
  if(self->impl->data.size >= cap) {
    return;
  }
  self->impl->data = nelua_GCAllocator_spanrealloc0__1(&self->allocator, self->impl->data, cap);
  nelua_assert_stringview((self->impl->data.size == cap), ((nlstringview){(uint8_t*)__strlit11, 31}));
}
void bug_sequence_int64_resize(bug_sequence_int64_ptr self, uintptr_t n) {
  bug_sequence_int64_reserve(self, n);
  for(uintptr_t i = (n + 1), __end = self->impl->size; i <= __end; i = i + 1) {
    (*bug_span_int64___atindex(&self->impl->data, i)) = 0;
  }
  self->impl->size = n;
}
void bug_sequence_int64_push(bug_sequence_int64_ptr self, int64_t v) {
  bug_sequence_int64_init(self);
  self->impl->size = (self->impl->size + 1);
  if(nelua_unlikely(((self->impl->size + 1) >= self->impl->data.size))) {
    bug_sequence_int64__grow(self);
  }
  nelua_memory_swapval__1((&(*bug_span_int64___atindex(&self->impl->data, self->impl->size))), (&v));
}
int64_t bug_sequence_int64_pop(bug_sequence_int64_ptr self) {
  nelua_assert_stringview((self->impl && (self->impl->size > 0)), ((nlstringview){(uint8_t*)__strlit12, 25}));
  int64_t ret = nelua_memory_moveval__1((&(*bug_span_int64___atindex(&self->impl->data, self->impl->size))));
  self->impl->size = (self->impl->size - 1);
  return ret;
}
void bug_sequence_int64_insert(bug_sequence_int64_ptr self, uintptr_t pos, int64_t v) {
  bug_sequence_int64_init(self);
  nelua_assert_stringview(((pos > 0) && (pos <= (self->impl->size + 1))), ((nlstringview){(uint8_t*)__strlit13, 39}));
  if(nelua_unlikely(((self->impl->size + 2) >= self->impl->data.size))) {
    bug_sequence_int64__grow(self);
  }
  self->impl->size = (self->impl->size + 1);
  if(self->impl->size > pos) {
    {
      nlint64_ptr __tmp1 = (&(*bug_span_int64___atindex(&self->impl->data, (pos + 1))));
      nlint64_ptr __tmp2 = (&(*bug_span_int64___atindex(&self->impl->data, pos)));
      nelua_memory_move((void*)__tmp1, (void*)__tmp2, ((self->impl->size - pos) * 8));
    };
    nelua_memory_zero((void*)(&(*bug_span_int64___atindex(&self->impl->data, pos))), 8U);
  }
  nelua_memory_swapval__1((&(*bug_span_int64___atindex(&self->impl->data, pos))), (&v));
}
int64_t bug_sequence_int64_remove(bug_sequence_int64_ptr self, uintptr_t pos) {
  nelua_assert_stringview((self->impl && (self->impl->size > 0)), ((nlstringview){(uint8_t*)__strlit14, 39}));
  int64_t ret = nelua_memory_moveval__1((&(*bug_span_int64___atindex(&self->impl->data, pos))));
  if(self->impl->size > pos) {
    {
      nlint64_ptr __tmp1 = (&(*bug_span_int64___atindex(&self->impl->data, pos)));
      nlint64_ptr __tmp2 = (&(*bug_span_int64___atindex(&self->impl->data, (pos + 1))));
      nelua_memory_move((void*)__tmp1, (void*)__tmp2, ((self->impl->size - pos) * 8));
    };
    nelua_memory_zero((void*)(&(*bug_span_int64___atindex(&self->impl->data, self->impl->size))), 8U);
  }
  self->impl->size = (self->impl->size - 1);
  return ret;
}
bool bug_sequence_int64_remove_value(bug_sequence_int64_ptr self, int64_t v) {
  if(!self->impl) {
    return false;
  }
  for(uintptr_t i = 1U, __end = self->impl->size; i <= __end; i = i + 1) {
    if((*bug_span_int64___atindex(&self->impl->data, i)) == v) {
      bug_sequence_int64_remove(self, i);
      return true;
    }
  }
  return false;
}
intptr_t bug_sequence_int64_capacity(bug_sequence_int64_ptr self) {
  if(nelua_unlikely(((!self->impl) || (self->impl->data.size == 0U)))) {
    return 0;
  }
  return ((intptr_t)self->impl->data.size - 1);
}
nlint64_ptr bug_sequence_int64___atindex(bug_sequence_int64_ptr self, uintptr_t i) {
  bug_sequence_int64_init(self);
  if(nelua_unlikely((i > self->impl->size))) {
    nelua_assert_stringview((i == (self->impl->size + 1)), ((nlstringview){(uint8_t*)__strlit15, 42}));
    self->impl->size = (self->impl->size + 1);
  }
  if(nelua_unlikely(((self->impl->size + 1) > self->impl->data.size))) {
    bug_sequence_int64__grow(self);
  }
  return (&(*bug_span_int64___atindex(&self->impl->data, i)));
}
intptr_t bug_sequence_int64___len(bug_sequence_int64_ptr self) {
  if(nelua_unlikely((!self->impl))) {
    return 0;
  }
  return (intptr_t)self->impl->size;
}
void bug_sequence_Color__grow(bug_sequence_Color_ptr self) {
  uintptr_t cap = (uintptr_t)2U;
  if(nelua_likely((self->impl->data.size != 0U))) {
    cap = (self->impl->data.size * 2);
  }
  self->impl->data = nelua_GCAllocator_spanrealloc0__2(&self->allocator, self->impl->data, cap);
  nelua_assert_stringview((self->impl->data.size == cap), ((nlstringview){(uint8_t*)__strlit9, 28}));
}
void bug_sequence_Color_init(bug_sequence_Color_ptr self) {
  if(nelua_likely(self->impl != NULL)) {
    return;
  }
  self->impl = ((bug_sequenceimpl_Color_ptr)nelua_GCAllocator_alloc0(&self->allocator, 24U));
  nelua_assert_stringview((self->impl != NULL), ((nlstringview){(uint8_t*)__strlit10, 28}));
}
void bug_sequence_Color_clear(bug_sequence_Color_ptr self) {
  if(!self->impl) {
    return;
  }
  if(self->impl->data.size != 0U) {
    for(uintptr_t i = 0U, __end = self->impl->size; i <= __end; i = i + 1) {
      (*bug_span_Color___atindex(&self->impl->data, i)) = (Color){0};
    }
  }
  self->impl->size = (uintptr_t)0U;
}
void bug_sequence_Color_destroy(bug_sequence_Color_ptr self) {
  if(!self->impl) {
    return;
  }
  bug_sequence_Color_clear(self);
  nelua_GCAllocator_spandealloc__2(&self->allocator, self->impl->data);
  self->impl->data = (bug_span_Color){0};
  nelua_GCAllocator_dealloc(&self->allocator, (void*)self->impl);
  self->impl = NULL;
}
void bug_sequence_Color_reserve(bug_sequence_Color_ptr self, uintptr_t n) {
  bug_sequence_Color_init(self);
  uintptr_t cap = (n + 1);
  if(self->impl->data.size >= cap) {
    return;
  }
  self->impl->data = nelua_GCAllocator_spanrealloc0__2(&self->allocator, self->impl->data, cap);
  nelua_assert_stringview((self->impl->data.size == cap), ((nlstringview){(uint8_t*)__strlit11, 31}));
}
void bug_sequence_Color_resize(bug_sequence_Color_ptr self, uintptr_t n) {
  bug_sequence_Color_reserve(self, n);
  for(uintptr_t i = (n + 1), __end = self->impl->size; i <= __end; i = i + 1) {
    (*bug_span_Color___atindex(&self->impl->data, i)) = (Color){0};
  }
  self->impl->size = n;
}
void bug_sequence_Color_push(bug_sequence_Color_ptr self, Color v) {
  bug_sequence_Color_init(self);
  self->impl->size = (self->impl->size + 1);
  if(nelua_unlikely(((self->impl->size + 1) >= self->impl->data.size))) {
    bug_sequence_Color__grow(self);
  }
  nelua_memory_swapval__2((&(*bug_span_Color___atindex(&self->impl->data, self->impl->size))), (&v));
}
Color bug_sequence_Color_pop(bug_sequence_Color_ptr self) {
  nelua_assert_stringview((self->impl && (self->impl->size > 0)), ((nlstringview){(uint8_t*)__strlit12, 25}));
  Color ret = nelua_memory_moveval__2((&(*bug_span_Color___atindex(&self->impl->data, self->impl->size))));
  self->impl->size = (self->impl->size - 1);
  return ret;
}
void bug_sequence_Color_insert(bug_sequence_Color_ptr self, uintptr_t pos, Color v) {
  bug_sequence_Color_init(self);
  nelua_assert_stringview(((pos > 0) && (pos <= (self->impl->size + 1))), ((nlstringview){(uint8_t*)__strlit13, 39}));
  if(nelua_unlikely(((self->impl->size + 2) >= self->impl->data.size))) {
    bug_sequence_Color__grow(self);
  }
  self->impl->size = (self->impl->size + 1);
  if(self->impl->size > pos) {
    {
      Color_ptr __tmp1 = (&(*bug_span_Color___atindex(&self->impl->data, (pos + 1))));
      Color_ptr __tmp2 = (&(*bug_span_Color___atindex(&self->impl->data, pos)));
      nelua_memory_move((void*)__tmp1, (void*)__tmp2, ((self->impl->size - pos) * 4));
    };
    nelua_memory_zero((void*)(&(*bug_span_Color___atindex(&self->impl->data, pos))), 4U);
  }
  nelua_memory_swapval__2((&(*bug_span_Color___atindex(&self->impl->data, pos))), (&v));
}
Color bug_sequence_Color_remove(bug_sequence_Color_ptr self, uintptr_t pos) {
  nelua_assert_stringview((self->impl && (self->impl->size > 0)), ((nlstringview){(uint8_t*)__strlit14, 39}));
  Color ret = nelua_memory_moveval__2((&(*bug_span_Color___atindex(&self->impl->data, pos))));
  if(self->impl->size > pos) {
    {
      Color_ptr __tmp1 = (&(*bug_span_Color___atindex(&self->impl->data, pos)));
      Color_ptr __tmp2 = (&(*bug_span_Color___atindex(&self->impl->data, (pos + 1))));
      nelua_memory_move((void*)__tmp1, (void*)__tmp2, ((self->impl->size - pos) * 4));
    };
    nelua_memory_zero((void*)(&(*bug_span_Color___atindex(&self->impl->data, self->impl->size))), 4U);
  }
  self->impl->size = (self->impl->size - 1);
  return ret;
}
inline bool nelua_eq_Color(Color a, Color b) {
  return a.r == b.r && a.g == b.g && a.b == b.b && a.a == b.a;
}

bool bug_sequence_Color_remove_value(bug_sequence_Color_ptr self, Color v) {
  if(!self->impl) {
    return false;
  }
  for(uintptr_t i = 1U, __end = self->impl->size; i <= __end; i = i + 1) {
    if(nelua_eq_Color((*bug_span_Color___atindex(&self->impl->data, i)), v)) {
      bug_sequence_Color_remove(self, i);
      return true;
    }
  }
  return false;
}
intptr_t bug_sequence_Color_capacity(bug_sequence_Color_ptr self) {
  if(nelua_unlikely(((!self->impl) || (self->impl->data.size == 0U)))) {
    return 0;
  }
  return ((intptr_t)self->impl->data.size - 1);
}
Color_ptr bug_sequence_Color___atindex(bug_sequence_Color_ptr self, uintptr_t i) {
  bug_sequence_Color_init(self);
  if(nelua_unlikely((i > self->impl->size))) {
    nelua_assert_stringview((i == (self->impl->size + 1)), ((nlstringview){(uint8_t*)__strlit15, 42}));
    self->impl->size = (self->impl->size + 1);
  }
  if(nelua_unlikely(((self->impl->size + 1) > self->impl->data.size))) {
    bug_sequence_Color__grow(self);
  }
  return (&(*bug_span_Color___atindex(&self->impl->data, i)));
}
intptr_t bug_sequence_Color___len(bug_sequence_Color_ptr self) {
  if(nelua_unlikely((!self->impl))) {
    return 0;
  }
  return (intptr_t)self->impl->size;
}
int nelua_main(int nelua_argc, char** nelua_argv) {
  {
    {
      {
        nelua_allocator = nelua_general_allocator;
      }
      nelua_default_allocator = (&nelua_gc_allocator);
    }
  }
  return 0;
}
